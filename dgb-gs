#!/bin/bash

# Project: Digibee Git Sync
HASH_VERSION=$(shasum $(echo $0) | awk '{print substr($1,0,5)}')
VERSION="v0.1.1.$HASH_VERSION"
# Written by: Artur Scheiner
# Email: artur.scheiner@gmail.com

############################################################
# Init                                                     #
############################################################
isLocal()[[ $0 == ./* ]]

THIS=$(echo $0 | awk -F'/' '{print $(NF)}')
CONFIG_FILE=~/.digibeectl/config.json
DGB_GS_DIR=~/.$THIS
DGB_GS_CACHE=$DGB_GS_DIR/cache
DGB_GS_PIPES=$DGB_GS_DIR/pipelines
USER_PATHS=$(echo ${PATH//:/ })

isLocal && THIS_TYPE="$0" || THIS_TYPE="$THIS"

Init()
{
    mkdir -p $DGB_GS_DIR $DGB_GS_CACHE $DGB_GS_PIPES
}

gitSync()
{
PIPE_NAME=$1
BASE_PATH=$HOME/.dgb-gs
mkdir -p $DGB_GS_PIPES/$PIPE_NAME

PIPE_PATH="$DGB_GS_PIPES/$PIPE_NAME"
PIPE_JSON="$PIPE_PATH/flowspec.json"
PIPE_LINE=$(digibeectl get pipeline -n $PIPE_NAME | awk 'NR==2')

IFS=" " read -r -a PIPE_INFO <<< "$PIPE_LINE"

PIPE_ID=${PIPE_INFO[1]}
PIPE_VERSION=${PIPE_INFO[2]}
PIPE_CHECKSUM=$(cat $PIPE_PATH/version.json | jq -r '.checksum')

echo "Sync - $PIPE_NAME"
echo "Pipeline ID - $PIPE_ID"
echo "Pipeline Version = $PIPE_VERSION"
echo "File output - $PIPE_JSON"
echo "Previous Checksum - $PIPE_CHECKSUM"

digibeectl get pipeline --pipeline-id $PIPE_ID --flowspec | jq > $PIPE_JSON 

#New Checksumm
PIPE_CHECKSUM=$(shasum $PIPE_JSON | awk '{print $1}' | awk '{print substr($0,0,5)}')

cat <<EOT > $PIPE_PATH/version.json
{
  "name" : "$PIPE_NAME",
  "id" : "$PIPE_ID",
  "version" : "$PIPE_VERSION",
  "checksum" : "$PIPE_CHECKSUM"
}
EOT

CreateReadme $PIPE_NAME

cd $PIPE_PATH
git add .
git commit -m "Version $PIPE_VERSION.$PIPE_CHECKSUM"
git push
}

Watch()
{
    PIPE_NAME=$1
    PIPE_LINE=$(digibeectl get pipeline -n $PIPE_NAME | awk 'NR==2')

    IFS=" " read -r -a PIPE_INFO <<< "$PIPE_LINE"

    PIPE_ID=${PIPE_INFO[1]}
    PIPE_VERSION=${PIPE_INFO[2]}

    echo "Sync - $PIPE_NAME"
    echo "Pipeline ID - $PIPE_ID"
    echo "Pipeline Version = $PIPE_VERSION"
    HASH_A=$(digibeectl get pipeline --pipeline-id $PIPE_ID --flowspec | shasum - | awk '{print $1}')
    while true
    do
      HASH_B=$(digibeectl get pipeline --pipeline-id $PIPE_ID --flowspec | shasum - | awk '{print $1}')
      if [ $HASH_A != $HASH_B ]
      then
        echo "different"
        $THIS -s $PIPE_NAME
        HASH_A=$HASH_B
      fi
      sleep 1
    done
}

############################################################
# Functions                                                #
############################################################
Help()
{
    Title "Help Information"
    printf "Syntax: $(TT bold)$THIS_TYPE [-a|l|r|s|c|d|h] params$(TT normal)\n\n"
    printf "$(TT yellow)about pipeline stuff$(TT white)\n"
    printf "a\tAdd a new pipeline git repo to the git sync list\n\tE.g. -> $(TT green)$THIS_TYPE -a $(TT underline)git@bitbucket.org:arturscheiner/pipeline-name.git$(TT normal; TT white)\n\n"
    printf "l\tList all the pipelines configured\n\tE.g. -> $(TT green)$THIS_TYPE -l$(TT white)\n\n"
    printf "r\tRemove a pipeline from the pipeline list\n\tE.g. -> $(TT green)$THIS_TYPE -r $(TT underline)pipeline-name$(TT normal; TT white)\n\n"
    printf "s\tSync a pipeline with its git repo\n\tE.g. -> $(TT green)$THIS_TYPE -s $(TT underline)pipeline-name$(TT normal; TT white)\n\n"
    printf "w\tWatch and sync when a pipeline changes\n\tE.g. -> $(TT green)$THIS_TYPE -w $(TT underline)pipeline-name$(TT normal; TT white)\n\n"
   
   printf "$(TT yellow)about this script$(TT white)\n"
   printf "c\tCheck this script deployment\n\tE.g. -> $(TT green)$THIS_TYPE -c$(TT white)\n\n"
    if [[ $0 == ./* ]]; then    
        printf "d\tDeploy this script into a directory\n\tE.g. -> $(TT green)sudo $THIS_TYPE -d /usr/local/bin$(TT white)\n\n"
    fi

    printf "$(TT yellow)about anything else$(TT white)\n"  
    printf "h\tShow this help information\n\tE.g. -> $(TT green)$THIS_TYPE -h$(TT white)\n\n"
}

TT()
{
    FORMAT=$1

    case $FORMAT in
        bold)
            tput bold
            ;;
        underline)
            tput smul
            ;;
        standout)
            tput smso
            ;;
        normal)
            tput sgr0
            ;;
        red)
            tput setaf 1
            ;;
        green)
            tput setaf 2
            ;;
        yellow)
            tput setaf 3
            ;;
        blue)
            tput setaf 4
            ;;
        magenta)
            tput setaf 5
            ;;
        cyan)
            tput setaf 6
            ;;
        white)
            tput setaf 7
            ;;
        *)
            tput sgr0
            ;;
    esac
}

spin() {
   local -a marks=( '/' '-' '\' '|' )
   while [[ 1 ]]; do
     printf '%s\r' "${marks[i++ % ${#marks[@]}]}"
     sleep 1
   done
 }

callForHelp(){ 
    printf "Check the help by running:\n\n\t$(TT green; TT bold)$THIS_TYPE -h$(TT normal)\n\n"
}

Error()
{
    MESSAGE=$1
    printf "$(TT red; TT bold)ERROR: $(TT white; TT normal)$MESSAGE\n\n"
}

Warning()
{
    MESSAGE=$1
    printf "$(TT yellow; TT bold)WARNING: $(TT white; TT normal)$MESSAGE\n\n"
}

Title()
{
    MESSAGE=$1
    [ -z $2 ] && COLOR="green" || COLOR=$2
    printf "$(TT $COLOR; TT bold)$MESSAGE$(TT normal; TT white)\n\n"
}

Check()
{
    Title "Check this script deployment and its dependencies"
    Title "about dependencies" white
    CheckDigibeeCtl
    CheckGit
    printf "\n"
    Title "about this script" white
    CheckThisScript
    printf "\n"
}

CheckThisScript()
{
  TRY_FIND=$(which $THIS)

    if [ -z $TRY_FIND ]
    then
        printf "$(TT red; TT bold)\xE2\x9C\x97$(TT white; TT normal) This script is not deployed on a PATH.\n" 
        printf "$(TT blue; TT bold)\xE2\x87\xB2$(TT white; TT normal) These are the available PATHS configured for this profile:\n"
        

        
        for p in $(echo $USER_PATHS); 
        do
            [ $p = "/usr/local/bin" ] && printf "  $(TT blue; TT bold)$p$(TT white; TT normal)\n" || printf "  $p\n"
        done
        
        printf "\n"
        printf "$(TT blue; TT bold)\xE2\x87\xB2$(TT white; TT normal) Deploy it using the recommended command from the current directory:\n\n"
        printf "  $(TT green; TT bold)sudo $0 -d /usr/local/bin$(TT white; TT normal)\n"
    else
        # printf "Seems that this script is already deployed on this system!\n"
        # printf "Check it out where it is deployed:\n\n"
        # printf "  $(TT blue; TT bold)$TRY_FIND$(TT white; TT normal)\n\n"
        CheckThisScriptVersion
    fi 
}

CheckThisScriptVersion()
{
  TRY_FIND=$(which $THIS)
  REPO_PATH="https://github.com/arturscheiner/dgb-gitsync.git"
  ONLINE_PATH="https://raw.githubusercontent.com/arturscheiner/dgb-gitsync/main/dgb-gs"
  DEPLOYED=$(shasum $(which $THIS) | awk '{print $1}')
  ACTUAL=$(shasum $(echo $0) | awk '{print $1}')
  ONLINE=$(shasum <(curl -s $ONLINE_PATH) | awk '{print $1}')

  if [ $DEPLOYED = $ACTUAL ]
  then
    printf "$(TT green; TT bold)\xE2\x9C\x94$(TT white; TT normal) The script is already deployed on your system: $(TT blue; TT bold)$TRY_FIND$(TT white; TT normal)\n"
  else
    printf "$(TT yellow; TT bold)\xE2\x8F\xB6$(TT white; TT normal) The script is different than the version deployed: $(TT green; TT bold)sudo $0 -d /usr/local/bin$(TT white; TT normal)\n"    
  fi

  if [[ $0 == ./* ]]; then    
    if [ $ACTUAL = $ONLINE ]
    then
    printf "$(TT green; TT bold)\xE2\x9C\x94$(TT white; TT normal) The script on this folder is the same available on its repo: $(TT blue; TT bold)$REPO_PATH$(TT white; TT normal)\n"
    else
    printf "$(TT yellow; TT bold)\xE2\x8F\xB6$(TT white; TT normal) The script on this folder is different than the one available on its repo: $(TT green; TT bold)git pull$(TT white; TT normal)\n"    
    fi
  fi


  if [ $DEPLOYED = $ONLINE ]
  then
    printf "$(TT green; TT bold)\xE2\x9C\x94$(TT white; TT normal) The script deployed is the same available on its repo: $(TT blue; TT bold)$REPO_PATH$(TT white; TT normal)\n"
  else
    printf "$(TT yellow; TT bold)\xE2\x8F\xB6$(TT white; TT normal) The script deployed is different than the one available on its repo: $(TT green; TT bold)$REPO_PATH$(TT white; TT normal)\n"    
  fi
}

CheckDigibeeCtl()
{
  TRY_DIGIBEECTL=$(which digibeectl)

  if [ -z $TRY_DIGIBEECTL ]
  then
    printf "$(TT yellow; TT bold)\u23f6$(TT white; TT normal) Git is not installed on your system: https://docs.digibee.com/documentation/platform/digibeectl\n"
  else
    printf "$(TT green; TT bold)\xE2\x9C\x94$(TT white; TT normal) Digibeectl is installed on your system: $(TT blue; TT bold)$TRY_DIGIBEECTL$(TT white; TT normal)\n"
    CheckDigibeeCtlConfig
  fi
}

CheckDigibeeCtlConfig()
{
  DGBCTLCONFIG=~/.digibeectl/config.json
  if [ -f $DGBCTLCONFIG ]
  then 
    printf "$(TT green; TT bold)\xE2\x9C\x94$(TT white; TT normal) Digibeectl is configured on your system: $(TT blue; TT bold)$DGBCTLCONFIG$(TT white; TT normal)\n"
  else
    printf "$(TT red; TT bold)\xE2\x9C\x97$(TT white; TT normal) Digibeectl is not configured on your system.\n"
  fi
}

CheckGit()
{
  TRY_GIT=$(which git)

  if [ -z $TRY_GIT ]
  then
    printf "$(TT yellow; TT bold)\u23f6$(TT white; TT normal) Git is not installed on your system.\n"
  else
    printf "$(TT green; TT bold)\xE2\x9C\x94$(TT white; TT normal) Git is installed on your system: $(TT blue; TT bold)$TRY_GIT$(TT white; TT normal)\n"
  fi
}

Deploy()
{
    Title "Deploy this script to a directory"
    echo "Sugested path is /usr/local/bin"

    echo $0
    TO_PATH=$1

    chmod +x $0

    if [ -f $TO_PATH/$THIS ]; then
        sudo rm $TO_PATH/$THIS
    fi

    sudo cp $0 $TO_PATH
}

addPipeGitRepo()
{
  PIPE_REPO=$1
  cd $DGB_GS_PIPES
  git clone $PIPE_REPO
  cd - 
}

List()
{
    Title "List configured pipelines"
    echo "The pipelines listed bellow are ready to be synched:"
    echo 
    ListPipelines
    echo
}

ListPipelines()
{
    ACTIVE_REALM=$(digibeectl get config | grep realm | awk '{print $2}')

    for c in $(ls $DGB_GS_PIPES); do
        [[ $c == $ACTIVE_REALM ]] && printf "\t$(TT bold; TT green)- $c (active)$(TT normal)\n" || printf "\t- $c\n"       
    done
    echo
}

CreateReadme()
{
  PIPE_NAME=$1
  PIPE_REPO_README=$DGB_GS_PIPES/$PIPE_NAME/README.md
  printf "## This is the pipeline $PIPE_NAME README:\n" > $PIPE_REPO_README
  CreatePipelineTree $PIPE_NAME >> $PIPE_REPO_README
}

CountPipelineLength()
{
 echo ""
}

CreatePipelineTree()
{
  PIPE_NAME=$1
  printf "## This is the pipeline components tree:\n"
  printf "\`\`\`bash\n"
  cat $DGB_GS_PIPES/$PIPE_NAME/flowspec.json | jq '.start[] | (.stepName)' | jq -r 
  printf "\`\`\`\n"
}

CheckSubTree()
{
 PIPE_NAME=$1
 TYPES="choice"

 EXPAND_TYPE=$(cat $DGB_GS_PIPES/$PIPE_NAME/flowspec.json | jq '.start[] | select(.type=="choice")')
 
 printf "## This is the pipeline component choice:\n"
  printf "\`\`\`bash\n"
  cat $DGB_GS_PIPES/$PIPE_NAME/flowspec.json | jq '.start[] | (.stepName)' | jq -r 
  printf "\`\`\`\n"
}

CheckChoiceTypeConnector()
{
  PIPE_NAME=$1
  TYPE="choice"
}

CheckBlockTypeConnectors()
{
  PIPE_NAME=$1
  CONNECTOR_NAMES="for-each-connector"
  PIPE_REPO_FLOWSPEC=$DGB_GS_DIR/$PIPE_NAME/flowspec.json
  LIST=$(jq '.start[] | select(.type=="choice") | {when} | .when[] | {target}' $PIPE_REPO_FLOWSPEC)
}

############################################################
# Main program                                             #
############################################################

############################################################
# Init program                                             #
############################################################
Init

############################################################
# Process the input options.                               #
############################################################
# Get the options
printf "$(TT magenta)Digibee$(TT white) Git Sync $VERSION\n\n"

OPTERR=0
OPTION=$1

isLocal && OPTIONS="hlca:s:r:d:w:" || OPTIONS="hlca:s:r:w:"

while getopts $OPTIONS option; do
   case $option in
      a) # config
         addPipeGitRepo $OPTARG
         exit;;
      h) # display Help
         Help
         exit;;
      s) # set active pipeline
         gitSync $OPTARG
         exit;;
      d) # deploy script to the /usr/local/bin
        #Check
        Deploy $OPTARG
         exit;;
      l) # list script
         List
         exit;;
      r) # list script
         Remove $OPTARG
         exit;;
      u) # unset active pipeline
         Unset
         echo
         exit;;
      w) # unset active pipeline
         Watch $OPTARG
         echo
         exit;;
    c) # unset active pipeline
        Check
        exit;;
     \?) # Invalid option
        Error "invalid option $OPTION or option without required config"
        callForHelp
        exit;;
   esac
done

if [[ -z $1 ]]; then
    Error "no option defined"
    callForHelp
fi